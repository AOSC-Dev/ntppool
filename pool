# -*- cperl -*-
eval 'exec $CBROOT/bin/perl $0 ${1+"$@"}'
  unless $running_under_some_shell;
use strict;
use lib "$ENV{CBROOTLOCAL}/lib";
use lib "$ENV{CBROOT}/lib";
use Combust::DB;
use List::Util qw(shuffle);
use Net::hostent;
use Net::IPv4Addr qw(ipv4_chkip);
use Net::NTP;
use Socket;
use Time::HiRes;
use Data::Dumper;
use Sys::Hostname qw(hostname);

use NTPPool::Server;

use constant LOGFILE => "$ENV{CBROOTLOCAL}/log";

$Net::NTP::TIMEOUT = 2;

my $db;

# exit handler
sub closedbconnection {
    $db->rollback();
    $db->disconnect();
}

# tools
sub ntpdate {
    my ($host, $error) = @_;

    my %ntp = eval { get_ntp_response($host); };
    warn Data::Dumper->Dump([\%ntp]);

    my @error;

    $ntp{Stratum} ||= '';
    push @error, "Bad stratum: $ntp{Stratum}"
      unless $ntp{Stratum}
      and $ntp{Stratum} < 6;

    if (@error) {
        print @error, "\n";
        my @query = `ntpdate -q $host 2>&1`
          or die "Error in command execution: ntpdate\n";
        print @query;

        return undef;
    }

    return 1;
}


sub logsay { 
    my $msg = join " ", @_;
    open LOG, ">>" . LOGFILE
      or die "Opening log (" . LOGFILE . "): $!\n";
    my (undef, undef, undef, $d, $m, $y, undef) = localtime time;
    printf LOG "%04d%02d%02d clockmaster %s\n", $y + 1900, $m + 1, $d, $msg;
    close LOG;
}

if ($#ARGV < 0) {
    die "pool add|report|scores|zone [<args>]\n";
}

# connect to the db
$db = Combust::DB::db_open('ntppool', {AutoCommit => 0})
  or die "Couldn't connect to database\n";

#$SIG{__DIE__} = \&closedbconnection;

my $cmd = shift @ARGV;
if ($cmd eq "add") {
    if ($#ARGV < 1) {
        die "pool add <email> <host or IP> [<zone ...>]\n";
    }

    # look if the email address is already registered
    my $email = $db->quote(shift @ARGV);
    my @row = $db->selectrow_array("SELECT id FROM users WHERE email = $email");
    my $emailid = $row[0];
    if ($#row == -1) {
        $db->do("INSERT INTO users (email) VALUES ($email)");
        $emailid = $db->{'mysql_insertid'};
    }

    # do we have a hostname or an IP?
    my $hostname = shift @ARGV;
    my $ip;
    if (ipv4_chkip $hostname) {
        $ip       = $hostname;
        $hostname = undef;
    }
    else {
        my $addrs = gethostbyname($hostname)
          or die "$hostname does not resolve.\n";
        if ($#{$addrs->addr_list} > 0) {
            print "warning: $hostname has multiple IP addresses.\n";
        }
        $ip = inet_ntoa(${$addrs->addr_list}[0]);
    }

    # test the timeserver
    ntpdate $ip, "Bad server " . ($hostname ? $hostname : "") . "[$ip]:"
      or exit;

    # insert into database
    @row =
      $db->selectrow_array("SELECT email FROM servers, users WHERE ip = '$ip' "
                           . "AND servers.admin = users.id");
    if ($#row != -1) {
        die "server $ip already in database for $row[0]\n";
    }
    $db->do("INSERT INTO servers (ip, admin, hostname) VALUES (?,?,?)",
            {}, $ip, $emailid, $hostname);
    my $serverid = $db->{'mysql_insertid'};

    # insert into zones
    foreach (@ARGV) {
        my $zone = $db->quote($_);
        @row = $db->selectrow_array("SELECT id FROM zones WHERE name = $zone");
        if (not @row or not $row[0]) {
            die "No such zone: $zone\n";
        }
        $db->do(  "INSERT INTO locations (server, zone) "
                . "VALUES ($serverid, $row[0])");
    }

    unless (defined $hostname) { $hostname = $ip; }
    my $z = join " ", @ARGV;
    logsay("$serverid add $email $hostname $z");

}
elsif ($cmd eq "rm") {
    my $arg = shift @ARGV
      or die "pool rm <host or IP>\n";
    my ($server) = NTPPool::Server->search(ip => $arg);
    ($server) = NTPPool::Server->search(hostname => $arg) unless $server;
    die "Could not find server $arg\n" unless $server;
    my $server_desc = (join " / ", grep { defined $_ } $server->ip, $server->hostname);
    logsay($server->id, "rm", $server_desc);
    printf "%i, %s - %s\n", $server->id, $server_desc, $server->admin->email;
    $server->delete;
}
elsif ($cmd eq "ip") {
    my ($from, $to) = @ARGV;
    $to or die "pool $cmd <host or IP> <IP>\n";
    my ($server) = NTPPool::Server->search(ip => $from);
    ($server) = NTPPool::Server->search(hostname => $from) unless $server;
    die "Could not find server $from\n" unless $server;
    my $server_desc = (join " / ", grep { defined $_ } $server->ip, $server->hostname);
    logsay($server->id, "ip", "$server_desc => $to");
    printf "%i, %s (%s) => %s\n", $server->id, $server_desc, $server->admin->email, $to;
    $server->ip($to);
    $server->update;
}
elsif ($cmd eq "report") {
    print <<'EOT';
From: pool.ntp.org monitoring script <clockmaster@fortytwo.ch>
To: <timekeepers-bulletin@fortytwo.ch>
Subject: Daily pool.ntp.org status report
MIME-Version: 1.0
Content-Type: text/plain; charset="us-ascii";
Content-Transfer-Encoding: 7bit
X-Script-Version: $Revision: 1.26 $

Servers with a score <= 5, currently not in the pool.ntp.org zone:

IP              score history
-------------------------------------------------------------------------
EOT
    my $badservers =
      $db->selectall_arrayref("SELECT sv.ip,sv.id,sc.score "
             . "FROM servers sv, scores sc "
             . "WHERE sv.id = sc.server AND sc.score <= 5 ORDER BY score DESC");
    foreach my $srv (@$badservers) {
        my $history = ...
        $history = scalar reverse @$history;
        printf "%-15s %6.1f %50s\n", $$srv[0], $$srv[2], $history;
    }
    print <<'EOT';
-------------------------------------------------------------------------

The history is one entry per hour (left is old values). Legend:
    #: server offset is ok
    x: server offset is tolerable
    o: server offset is too big
    _: server is unreachable

Comments welcome on the timekeepers@fortytwo.ch mailing list.
EOT
}
elsif ($cmd eq "scores") {
    $db->do("UPDATE scores SET score = score * 0.95");

    # check if this machine has good time.
    $Net::NTP::CLIENT_TIME_SEND    = undef;
    $Net::NTP::CLIENT_TIME_RECEIVE = undef;
    my $mon_host = 'localhost';
    $mon_host = 'miette' if hostname eq "powermac.bn.dev";
    my %pkt = get_ntp_response($mon_host);
    if ($pkt{'Stratum'} == 0 or $pkt{'Stratum'} > 6) {
        die "monitoring server not synchronized\n";
    }

    # and if we're connected
    $Net::NTP::CLIENT_TIME_SEND    = undef;
    $Net::NTP::CLIENT_TIME_RECEIVE = undef;
    %pkt = eval { get_ntp_response('clock-a.develooper.com'); };
    if ($pkt{'Stratum'} == 0 or $pkt{'Stratum'} > 6) {
        $Net::NTP::CLIENT_TIME_SEND    = undef;
        $Net::NTP::CLIENT_TIME_RECEIVE = undef;
        %pkt = eval { get_ntp_response('clock-b.develooper.com'); };
        if ($pkt{'Stratum'} == 0 or $pkt{'Stratum'} > 6) {
            die "no time from clock-a or clock-b\n";
        }
    }

    # go through server array and fetch offset for all servers
    my $srv =
      $db->selectall_arrayref("SELECT sr.id, sr.ip, sc.score "
            . "FROM servers sr LEFT OUTER JOIN scores sc ON sr.id = sc.server");
    foreach my $s (@$srv) {
        my $step = 0;
        if (not defined $$s[2]) {

            # start at score = 0 if new server
            $$s[2] = 0;
        }

        #print "testing $$s[1]\n";

        # fetch offset by ntp
        # if a server is not good, query a second time
        # and use the second result - this is said to solve problems with some
        # crappy Internet access routers.
        my $offset = undef;
        for (my $i = 0 ; $step != 1 and $i < 2 ; $i++) {
            $Net::NTP::CLIENT_TIME_RECEIVE = undef;
            my $time_then = Time::HiRes::time;
            $Net::NTP::CLIENT_TIME_SEND = $time_then;
            my %pkt      = eval { get_ntp_response($$s[1]) };
            my $time_now = Time::HiRes::time;

            if ($!) {
                $step = -5;
            }
            else {
                my $recv_org   = $pkt{'Receive Timestamp'} - $time_now;
                my $trans_dest = $pkt{'Transmit Timestamp'} - $time_then;
                $offset = abs(($recv_org + $trans_dest) / 2);
                if ($offset > 3) {
                    $step = -4;
                }
                elsif ($offset > 1.5) {
                    $step = -2;
                }
                elsif ($offset > 0.5) {
                    $step = -2 * $offset + 2;
                }
                else {
                    $step = 1;
                }
            }
        }

        if (not defined $offset) { $offset = "NULL"; }
        if (
            $db->do(
                        "UPDATE scores SET score = score + $step, ts=now() "
                      . "WHERE server = $$s[0]"
            ) != 1
           )
        {
            $db->do(  "INSERT INTO scores (server, score) "
                    . "VALUES ($$s[0], $step)");
        }
        $db->do(  "INSERT INTO log_scores "
                . "(server, score, step, offs) "
                . "VALUES ($$s[0], $$s[2] + $step, $step, $offset)");
    }
}
elsif ($cmd eq "zone") {

    my $file = "/home/ask/bsb-out/pool.ntp.org";
    open(my $fh, ">$file.tmp") or die "Could not open $file.tmp: $!";

    open HEAD, "<header"
      or die "Opening DNS zone file header ($ENV{HOME}/db/header): $!\n";
    print $fh "# ATTENTION\n# This is a generated file\n#\n";
    my $t = time;
    while (<HEAD>) {
        s/\@VERSION\@/$t/;
        print $fh $_;
    }
    close HEAD;

    my $ttl = 120;

    my $entries =
      $db->selectall_arrayref(  "SELECT s.ip "
                              . "FROM servers s, scores sc "
                              . "WHERE sc.server = s.id AND sc.score > 5");
    if ($#$entries < 59) {
        print $fh "# possible duplicates in the zones below (@)\n";
        for my $zone (("@", "0", "1", "2")) {
            my $z = $zone eq '@' ? '' : "$zone.";
            @$entries = shuffle(@$entries);
            my $i;
            foreach my $e (@$entries) {
                #print "$z IN A $$e[0]\n";
                print $fh "+${z}pool.ntp.org:$$e[0]:$ttl\n";
                $i++;
                last if ($i >= 15);
            }
        }
    }
    else {
        print $fh "#; 'big' zone without duplicates below (@)\n";
        @$entries = shuffle(@$entries);
        for my $zone (("@", "0", "1", "2")) {
            my $z = $zone eq '@' ? '' : "$zone.";
            for (my $i = 0 ; $i < 15 ; $i++) {
                print $fh "+${z}pool.ntp.org:", ${shift @$entries}[0], ":$ttl\n";
            }
        }
    }

    my $zones = $db->selectall_arrayref("SELECT id, name FROM zones");
    for my $zone (@$zones) {
        $entries =
          $db->selectall_arrayref("SELECT s.ip "
                               . "FROM servers s, scores sc, locations l "
                               . "WHERE l.server = s.id AND l.zone = $$zone[0] "
                               . "AND sc.server = s.id AND sc.score > 5");
        if ($#$entries < 59) {
            print $fh "# possible duplicates in the zones below ($$zone[1])\n";
            foreach my $z (("", "0.", "1.", "2.")) {
                @$entries = shuffle(@$entries);
                my $i;
                foreach my $e (@$entries) {
                    print $fh "+$z$$zone[1].pool.ntp.org:$$e[0]:$ttl\n";
                    $i++;
                    last if ($i >= 15);
                }
            }
        }
        else {
            print $fh "# 'big' zone without duplicates below ($$zone[1])\n";
            @$entries = shuffle(@$entries);
            foreach my $z (("", "0.", "1.", "2.")) {
                for (my $i = 0 ; $i < 15 ; $i++) {
                    print $fh "+$z$$zone[1].pool.ntp.org:", ${shift @$entries}[0], ":120\n";
                }
            }
        }
    }
    close $fh or die "could not close $file.tmp: $!";
    rename "$file.tmp", "$file.tinydns" or die "could not rename $file.tmp to $file.tinydns: $!";
}
else {
    die "Unknown command: $cmd\n";
}

$db->commit() or die "Error on commit\n";
$SIG{__DIE__} = 'DEFAULT';
$db->disconnect();

    
