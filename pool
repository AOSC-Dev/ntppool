# -*- cperl -*-
eval 'exec $CBROOT/bin/perl $0 ${1+"$@"}'
  unless $running_under_some_shell;
use strict;
use lib "$ENV{CBROOTLOCAL}/lib";
use lib "$ENV{CBROOT}/lib";
use Combust::DB;
use List::Util qw(shuffle);
use Net::hostent;
use Net::NTP;
use Socket;
use Time::HiRes;
use Data::Dumper;
use Sys::Hostname qw(hostname);
use Geo::IP;
use LWP::Simple;
use Email::Simple;
use Email::Date;
use Email::Send 'SMTP';

my $gi = Geo::IP->new(GEOIP_STANDARD);

use NTPPool::Server;

use constant LOGFILE => "$ENV{CBROOTLOCAL}/log";

$Net::NTP::TIMEOUT = 2;

my $db;

# exit handler
sub closedbconnection {
    $db->rollback();
    $db->disconnect();
}

# tools
sub ntpdate {
    my ($host, $error) = @_;

    my %ntp = eval { get_ntp_response($host); };
    warn Data::Dumper->Dump([\%ntp]);

    my @error;

    $ntp{Stratum} ||= '';
    push @error, "Bad stratum: $ntp{Stratum}"
      unless $ntp{Stratum}
      and $ntp{Stratum} < 6;

    if (@error) {
        print @error, "\n";
        my @query = `ntpdate -q $host 2>&1`
          or die "Error in command execution: ntpdate\n";
        print @query;

        return undef;
    }

    return 1;
}


sub logsay { 
    my $msg = join " ", @_;
    open LOG, ">>" . LOGFILE
      or die "Opening log (" . LOGFILE . "): $!\n";
    my (undef, undef, undef, $d, $m, $y, undef) = localtime time;
    printf LOG "%04d%02d%02d clockmaster %s\n", $y + 1900, $m + 1, $d, $msg;
    close LOG;
}

sub server_information {
    my $server = shift;
    my @zones  = $server->zones;
    my @r;
    push @r, sprintf "IP: %s, ID: %i, username: %s email: %s\n",
      $server->ip,
      $server->id,
      $server->admin->username ? $server->admin->username : "-",
      $server->admin->email; 
    push @r, sprintf "score: %.1f, in pool: %i, in server list: %i\n", $server->score, $server->in_pool, $server->in_server_list;
    push @r, "Hostname: " . $server->hostname . "\n";
    my $gi = Geo::IP->new(GEOIP_STANDARD);
    my $country = $gi->country_code_by_addr($server->ip);
    $country = lc $country if $country;
    push @r, "Country: $country  -  " if $country;
    push @r, "Netspeed: " . $server->netspeed . "\n";
    push @r, "Zones: ", join (", ", map { $_->name } @zones), "\n";
    push @r, sprintf "in_pool: %i, in_server_list: %i\n", $server->in_pool, $server->in_server_list;
    @r;
}

if ($#ARGV < 0) {
    die "pool add|report|scores|zone [<args>]\n";
}

# connect to the db
$db = Combust::DB::db_open('ntppool', {AutoCommit => 0})
  or die "Couldn't connect to database\n";

#$SIG{__DIE__} = \&closedbconnection;

my $cmd = shift @ARGV;
if ($cmd eq "add") {
    if ($#ARGV < 1) {
        die "pool add <email> <host or IP> [<zone ...>]\n";
    }

    # look if the email address is already registered
    my $email = shift @ARGV;
    my ($user) = NTPPool::Admin->search(email => $email);
    ($user) = NTPPool::Admin->search(username => $email) unless $user;
    ($user) = NTPPool::Admin->search(id => $email) unless $user;
    $user = NTPPool::Admin->create({ email => $email} ) unless $user;

    # do we have a hostname or an IP?
    my $hostname = shift @ARGV;
    my $ip;
    require Net::IPv4Addr;
    if (Net::IPv4Addr::ipv4_chkip($hostname)) {
        $ip       = $hostname;
        $hostname = undef;
    }
    else {
        my $addrs = gethostbyname($hostname)
          or die "$hostname does not resolve.\n";
        if ($#{$addrs->addr_list} > 0) {
            print "warning: $hostname has multiple IP addresses.\n";
        }
        $ip = inet_ntoa(${$addrs->addr_list}[0]);
    }

    # test the timeserver
    ntpdate $ip, "Bad server " . ($hostname ? $hostname : "") . "[$ip]:"
      or exit;

    # insert into database
    my @row = $db->selectrow_array("SELECT email FROM servers, users WHERE ip = '$ip' "
                                   . "AND servers.admin = users.id");
    if ($#row != -1) {
        die "server $ip already in database for $row[0]\n";
    }

    my $s = NTPPool::Server->create
      ({ ip       => $ip,
         hostname => $hostname,
         admin    => $user->id,
         in_pool  => 1,
       });
    for my $country (@ARGV) {
        my $zone = NTPPool::Zone->retrieve_by_name($country);
        $s->add_to_locations({ zone => $zone });
    }
        
    unless (defined $hostname) { $hostname = $ip; }
    my $z = join " ", @ARGV;
    logsay($s->id . " add $email $hostname $z");

}
elsif ($cmd eq "edit") {
    my $arg = shift @ARGV or die "pool zones <host or IP>\n";
    my $server = NTPPool::Server->find_server($arg);
    die "Could not find server $arg\n" unless $server;
    print server_information($server);
    while (my $k = shift @ARGV) {
        print "\n";
        my $v = shift @ARGV;
        last unless defined $v;
        print "Set $k -> $v";
        if ($server->can($k)) {
            $server->$k($v);
        }
        else {
            die "Don\'t know how to set $k\n";
        }
    }
    if ($server->update > 0) {
        print "\n\nUpdated =============\n";
        print server_information($server);
    }
}
elsif ($cmd eq "zones") {
    my $arg = shift @ARGV or die "pool zones <host or IP>\n";
    my $server = NTPPool::Server->find_server($arg);
    die "Could not find server $arg\n" unless $server;
    print server_information($server);
    my @zones  = $server->zones;
    for my $zone_name (@ARGV) {
        my @locations = $server->locations;
        if ($zone_name =~ s/^-//) {
            my ($location) = grep { $_->zone->name eq $zone_name } @locations;
            print "Could not find location '$zone_name' to delete\n" and next unless $location;
            $server->leave_zone($zone_name);
        }
        else {
            $zone_name =~ s/^\+//;
            next if grep { $zone_name eq $_->name } @zones;
            my ($zone) = NTPPool::Zone->retrieve_by_name($zone_name);
            print "Could not find '$zone_name'\n" and next unless $zone;
            $server->join_zone($zone);
        }
    }
    @zones  = $server->zones;
    print "Zones: ", join (", ", map { $_->name } @zones), "\n";
}
elsif ($cmd eq "rm") {
    my $arg = shift @ARGV
      or die "pool rm <host or IP>\n";
    my $server = NTPPool::Server->find_server($arg);
    die "Could not find server $arg\n" unless $server;
    my $server_desc = (join " / ", grep { defined $_ } $server->ip, $server->hostname);
    logsay($server->id, "rm", $server_desc);
    printf "%i, %s - %s\n", $server->id, $server_desc, $server->admin->email;
    $server->delete;
}
elsif ($cmd eq "ip") {
    my ($from, $to) = @ARGV;
    $to or die "pool $cmd <host or IP> <IP>\n";
    my $server = NTPPool::Server->find_server($from);
    die "Could not find server $from\n" unless $server;
    my $server_desc = (join " / ", grep { defined $_ } $server->ip, $server->hostname);
    logsay($server->id, "ip", "$server_desc => $to");
    printf "%i, %s (%s) => %s\n", $server->id, $server_desc, $server->admin->email, $to;
    $server->ip($to);
    $server->score_raw(0);
    $server->update;
}
elsif ($cmd eq "report") {

    my $rcpt = shift;

    my $config = Combust::Config->new;
    my $url = $config->base_url("ntppool") . "/bulletin";
    my $msg = get($url);

    die "no msg?!" unless $msg;

    my $head = "";

    $rcpt and $head = <<EOT;
From: pool.ntp.org monitoring script <clockmaster\@fortytwo.ch>
To: <$rcpt>
EOT

    #  timekeepers-bulletin@fortytwo.ch

    if ($rcpt) {
        my $email = Email::Simple->new($head . $msg);
        $email->header_set('Message-ID' => join("-", int(rand(1000)), $$, time) . '@' . hostname);
        $email->header_set('Date'       => Email::Date::format_date);

        my $return = send SMTP => $email, 'localhost';
    }
    else {
        print $msg;
    }

}
elsif ($cmd eq "scores") {

    my $dbh = NTPPool::DBI->dbh;
    $dbh->selectrow_array(q[SELECT GET_LOCK("scores", 0)]) or exit;

    # check if this machine has good time.
    $Net::NTP::CLIENT_TIME_SEND    = undef;
    $Net::NTP::CLIENT_TIME_RECEIVE = undef;
    my $mon_host = 'localhost';
    $mon_host = 'miette.bn.dev' if hostname =~ m/bn.dev$/;
    my %pkt = get_ntp_response($mon_host);
    if ($pkt{'Stratum'} == 0 or $pkt{'Stratum'} > 6) {
        die "monitoring server not synchronized\n";
    }

    # and if we're connected
    $Net::NTP::CLIENT_TIME_SEND    = undef;
    $Net::NTP::CLIENT_TIME_RECEIVE = undef;
    %pkt = eval { get_ntp_response('clock-a.develooper.com'); };
    if ($pkt{'Stratum'} == 0 or $pkt{'Stratum'} > 6) {
        $Net::NTP::CLIENT_TIME_SEND    = undef;
        $Net::NTP::CLIENT_TIME_RECEIVE = undef;
        %pkt = eval { get_ntp_response('clock-b.develooper.com'); };
        if ($pkt{'Stratum'} == 0 or $pkt{'Stratum'} > 6) {
            die "no time from clock-a or clock-b\n";
        }
    }

    # go through server array and fetch offset for all servers
    my $servers = NTPPool::Server->search_check_due;

    while (my $server = $servers->next) { 
        my $step = 0;

        $server->score_raw( $server->score_raw * 0.95 );

        #printf "testing %s\n", $server->ip;

        # fetch offset by ntp
        # if a server is not good, query a second time
        # and use the second result - this is said to solve problems with some
        # crappy Internet access routers.
        my $offset = undef;
        for (my $i = 0 ; $step != 1 and $i < 2 ; $i++) {
            $Net::NTP::CLIENT_TIME_RECEIVE = undef;
            my $time_then = Time::HiRes::time;
            $Net::NTP::CLIENT_TIME_SEND = $time_then;

            my %pkt      = eval { 
                get_ntp_response($server->ip) 
            };
            my $time_now = Time::HiRes::time;

            if (!$pkt{Stratum} or $!) {
                $step = -5;
            }
            else {
                my $recv_org   = $pkt{'Receive Timestamp'} - $time_now;
                my $trans_dest = $pkt{'Transmit Timestamp'} - $time_then;
                $offset = abs(($recv_org + $trans_dest) / 2);
                if ($offset > 3 or $pkt{Stratum} > 5) {
                    $step = -4;
                }
                elsif ($offset > 1.5) {
                    $step = -2;
                }
                elsif ($offset > 0.1) {
                    $step = -2 * $offset + 1;
                }
                else {
                    $step = 1;
                }
            }

            $server->stratum($pkt{Stratum}) if $pkt{Stratum};
        }

        $server->score_raw( $server->score_raw + $step );
        $server->add_to_log_scores({ score  => $server->score, 
                                     step   => $step,
                                     offset => $offset,
                                   });
        $server->update;
    }
}
elsif ($cmd eq "zone") {

    my $file = "bsb-out/pool.ntp.org";
    open(my $fh, ">$file.tmp") or die "Could not open $file.tmp: $!";

    open HEAD, "<header"
      or die "Opening DNS zone file header (header): $!\n";
    print $fh "# ATTENTION\n# This is a generated file\n#\n";
    my $t = time;
    while (<HEAD>) {
        s/\@VERSION\@/$t/;
        print $fh $_;
    }
    close HEAD;

    my $vendordir = "vendordns";
    opendir my $dir, $vendordir or die "could not open '$vendordir' dir: $!";
    my @vendor_files = grep { $_ !~ /\~$/ and -f $_ } map { "$vendordir/$_" } readdir($dir);
    closedir $dir;

    for my $file (@vendor_files) {
       open my $vfh, $file or die "could not open $file: $!";
       while (<$vfh>) {
         last if m/^--/;
         print $fh $_; 
       }
       close $vfh;
    }


    my $ttl = 2700;

    my $zones = NTPPool::Zone->search( dns => 1 );
    while (my $zone = $zones->next) {
        my $name = $zone->name;
	$name = '' if $name eq '@';
	$name = "$name." if $name;

        my $entries =
          $db->selectall_arrayref("SELECT s.ip "
                               . "FROM servers s, scores sc, locations l "
                               . "WHERE l.server = s.id AND l.zone = ? AND s.in_pool = 1 "
                               . "AND sc.server = s.id AND sc.score > 5", undef, $zone->id);

        next unless $entries and @$entries;

        my $min_non_duplicate_size = 4;
        $min_non_duplicate_size = int(@$entries / 5) 
          if (@$entries / 5 > $min_non_duplicate_size);
        $min_non_duplicate_size = 12 if $min_non_duplicate_size > 12;

        print $fh "# " . scalar @$entries . " active servers in ", $zone->name, "\n";

        if ($#$entries < ($min_non_duplicate_size*5 - 1)) {
            print $fh "# possible duplicates in the zones below (", $zone->name, ")\n";
            foreach my $z (("", "0.", "1.", "2.", "3.")) {
                @$entries = shuffle(@$entries);
                my $i;
                foreach my $e (@$entries) {
                    print $fh "+$z${name}pool.ntp.org:$$e[0]:$ttl\n";
                    $i++;
                    last if ($i >= 14);
                }
            }
        }
        else {
            print $fh "# 'big' zone without duplicates below (", $zone->name, ")\n";
            @$entries = shuffle(@$entries);
            foreach my $z (("", "0.", "1.", "2.", "3.")) {
                for (my $i = 0 ; $i < $min_non_duplicate_size; $i++) {
                    print $fh "+$z${name}pool.ntp.org:", ${shift @$entries}[0], ":$ttl\n";
                }
            }
        }
    }
    close $fh or die "could not close $file.tmp: $!";
    rename "$file.tmp", "$file.tinydns" or die "could not rename $file.tmp to $file.tinydns: $!";
}
else {
    die "Unknown command: $cmd\n";
}

#$db->commit() or die "Error on commit\n";
$SIG{__DIE__} = 'DEFAULT';
$db->disconnect();

    
